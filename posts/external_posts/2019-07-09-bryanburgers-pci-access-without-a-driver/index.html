<!doctype html><html lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><title>SFDevs | PCI Access Without a Driver</title><meta name=description content="At work recently, I had a new PCI device that I needed to experiment with. I was dreading writing a Linux kernel driver to talk to it. It turns out, Linux makes it possible to read and write to a PCI device&rsquo;s memory space without a driver! Woohoo!
Linux provides a sysfs interface to PCI devices. From that interface, the memory space can be mmaped and then read and written. No driver involved."><link rel="shortcut icon" href=favicon.ico type=image/x-icon><link rel=icon href=favicon.ico type=image/x-icon><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.63.2"><script defer src=https://use.fontawesome.com/releases/v5.8.1/js/solid.js integrity=sha384-IA6YnujJIO+z1m4NKyAGvZ9Wmxrd4Px8WFqhFcgRmwLaJaiwijYgApVpo1MV8p77 crossorigin=anonymous></script><script defer src=https://use.fontawesome.com/releases/v5.8.1/js/brands.js integrity=sha384-rUOIFHM3HXni/WG5pzDhA1e2Js5nn4bWudTYujHbbI9ztBIxK54CL4ZNZWwcBQeD crossorigin=anonymous></script><script defer src=https://use.fontawesome.com/releases/v5.8.1/js/fontawesome.js integrity=sha384-EMmnH+Njn8umuoSMZ3Ae3bC9hDknHKOWL2e9WJD/cN6XLeAN7tr5ZQ0Hx5HDHtkS crossorigin=anonymous></script><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Montserrat:500,900|Knewave"><link rel=stylesheet href=/styles/main.9c4982b854aa3918177d1f17977e6e14de523c80837b521ddeaf47ad11decd09.css integrity="sha256-nEmCuFSqORgXfR8Xl35uFN5SPICDe1Id3q9HrRHezQk="><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#6cc091><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#6cc091"><link rel=canonical href=https://burgers.io/pci-access-without-a-driver><meta property="og:title" content="PCI Access Without a Driver"><meta property="og:description" content="At work recently, I had a new PCI device that I needed to experiment with. I was dreading writing a Linux kernel driver to talk to it. It turns out, Linux makes it possible to read and write to a PCI device&rsquo;s memory space without a driver! Woohoo!
Linux provides a sysfs interface to PCI devices. From that interface, the memory space can be mmaped and then read and written. No driver involved."><meta property="og:type" content="article"><meta property="og:url" content="https://sfdevs.com/posts/external_posts/2019-07-09-bryanburgers-pci-access-without-a-driver/"><meta property="article:published_time" content="2019-07-09T19:45:00+00:00"><meta property="article:modified_time" content="2019-07-09T19:45:00+00:00"><meta property="fb:app_id" content="1171673062996168"><meta itemprop=name content="PCI Access Without a Driver"><meta itemprop=description content="At work recently, I had a new PCI device that I needed to experiment with. I was dreading writing a Linux kernel driver to talk to it. It turns out, Linux makes it possible to read and write to a PCI device&rsquo;s memory space without a driver! Woohoo!
Linux provides a sysfs interface to PCI devices. From that interface, the memory space can be mmaped and then read and written. No driver involved."><meta itemprop=datePublished content="2019-07-09T19:45:00+00:00"><meta itemprop=dateModified content="2019-07-09T19:45:00+00:00"><meta itemprop=wordCount content="471"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="PCI Access Without a Driver"><meta name=twitter:description content="At work recently, I had a new PCI device that I needed to experiment with. I was dreading writing a Linux kernel driver to talk to it. It turns out, Linux makes it possible to read and write to a PCI device&rsquo;s memory space without a driver! Woohoo!
Linux provides a sysfs interface to PCI devices. From that interface, the memory space can be mmaped and then read and written. No driver involved."><meta name=twitter:site content="@_sfdevs"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-89597259-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script>window.fbAsyncInit=function(){FB.init({appId:'1171673062996168',cookie:true,xfbml:true,version:'v3.2'});FB.AppEvents.logPageView();};(function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(d.getElementById(id)){return;}
js=d.createElement(s);js.id=id;js.src="https://connect.facebook.net/en_US/sdk.js";fjs.parentNode.insertBefore(js,fjs);}(document,'script','facebook-jssdk'));</script><body class=subpage><header id=header><div class=inner><a href=https://sfdevs.com/ class=logo>SFDevs</a><nav id=nav role=menu><a href=/about/><span>About</span></a>
<a href=/posts/><span>Community Posts</span></a>
<a href=/jobs/><span>Jobs</span></a></nav><a href=#navPanel class=navPanelToggle><span class="fa fa-bars"></span></a></div></header><section class=wrapper><div class=inner><header class=align-center><h1>PCI Access Without a Driver</h1></header><p>At work recently, I had a new PCI device that I needed to experiment with. I
was dreading writing a Linux kernel driver to talk to it. It turns out, Linux
makes it possible to read and write to a PCI device&rsquo;s memory space without a
driver! Woohoo!</p><p>Linux provides a <a href=https://github.com/torvalds/linux/blob/master/Documentation/filesystems/sysfs-pci.txt>sysfs interface to PCI devices</a>. From that
interface, the memory space can be <code>mmap</code>ed and then read and written. No
driver involved.</p><p>As a quick example, we can use <code>lspci</code> to get information about a particular
device.</p><pre><code>$ vendor=&amp;quot;10ee&amp;quot; # Use your device ID
$ device=&amp;quot;7014&amp;quot; # Use your vendor ID
$ lspci -d $vendor:$device -nvv
04:00.0 1180: 10ee:7014
    ...
    Region 0: Memory at f7300000 (32-bit, non-prefetchable) [size=128K]

</code></pre><p>Then we can look at the sysfs interface, at <code>/sys/bus/pci/devices/</code>. The first
bit of data in the output of <code>lspci</code> gives the location of the device on the
bus, that we can use when traversing the sysfs interface.</p><pre><code>$ ls -alF /sys/bus/pci/devices/0000\:04\:00.0/
total 0
drwxr-xr-x 3 root root      0 Jul  1 12:42 ./
drwxr-xr-x 8 root root      0 Jul  1 12:42 ../
-rw-r--r-- 1 root root   4096 Jul  9 12:48 broken_parity_status
-r--r--r-- 1 root root   4096 Jul  1 12:42 class
-rw-r--r-- 1 root root   4096 Jul  9 12:44 config
-r--r--r-- 1 root root   4096 Jul  1 12:42 device
...
-r--r--r-- 1 root root   4096 Jul  1 12:43 resource
-rw------- 1 root root 131072 Jul  1 12:43 resource0
...
-r--r--r-- 1 root root   4096 Jul  1 12:42 vendor

</code></pre><p>This interface has some useful files like <code>vendor</code> and <code>device</code> that confirm
that we have the right device. These are also useful for programatically
finding the correct device, rather than using <code>lspci</code>.</p><pre><code>$ cat /sys/bus/pci/devices/0000\:04\:00.0/vendor
0x10ee
$ cat /sys/bus/pci/devices/0000\:04\:00.0/device
0x7014

</code></pre><p>Looking back at the <code>lspci</code> output, we can also find memory resources and
addresses. These are represented as <code>resource0</code>&mldr;<code>resourceN</code> in the sysfs
interface. That&rsquo;s what we use to get access to the PCI memory space.</p><p>Open the <code>resource0</code> file (which can be some number other than 0 depending on
the device).</p><pre><code>int fd = open(&amp;quot;/sys/bus/pci/devices/0000:04:00.0/resource0&amp;quot;, O_RDWR | O_SYNC);

</code></pre><p>Then use the memory address and size from the <code>lspci</code> output to <code>mmap</code> the
file.</p><pre><code>void* base_address = (void*)0xf7300000;
size_t size = 128 * 1024; // 128K
void* void_memory = mmap(base_address,
                         size,
                         PROT_READ | PROT_WRITE,
                         MAP_SHARED,
                         fd,
                         0);
uint16_t* memory = (uint16_t*)void_memory;

</code></pre><p>Now <code>memory</code> provides direct access to read and write the PCI memory space.
We can hack away!</p><pre><code>// Read the value of the first register
uint16_t first_register = memory[0];

// Write a value to the third register
memory[2] = 0x0007;

</code></pre><p>Now, this isn&rsquo;t the perfect scenario. For one, we need to be <code>root</code> to access
this memory space. For two, there&rsquo;s no sign of interrupt handling anywhere.</p><p>But for basic poking around on a new device, it works pretty slick. No kernel
module development required.</p></div></section><footer id=footer><div class=inner><h3>Get in touch</h3><iframe src="https://services.cognitoforms.com/f/kLQF89okA06rKO0JYMWNOg?id=1" style=position:relative;width:1px;min-width:100%;*width:100% frameborder=0 scrolling=yes seamless height=465 width=100%></iframe>
<script src=https://services.cognitoforms.com/scripts/embed.js></script><div class="row footer__copy-social"><div class="copyright 6u 12u$(small)">&copy; 2020 Sioux Falls Developer's Group.</div><div class="6u 12u$(small) social"><div class=footer__social><span class=follow__social__copy>Follow SFDevs</span>
<a href=https://www.facebook.com/sfdevs title="Follow us on Facebook" class=like-us target=_blank rel=noopener><i class="fab fa-facebook fa-2x"></i></a><a href=https://twitter.com/_sfdevs title="Follow us on Twitter" class=like-us target=_blank rel=noopener><i class="fab fa-twitter fa-2x"></i></a></div></div></div></div></footer><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity="sha256-3edrmyuQ0w65f8gfBsqowzjJe2iM6n0nKciPUp8y+7E=" crossorigin=anonymous></script><script src=/js/skel.min.js></script><script src=/js/main.min.js></script></body></html>